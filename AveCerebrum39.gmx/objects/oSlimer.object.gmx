<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sSlimer</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>oAi</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>InitializeAi("Enemy", "Magpie", "Melee", sSlimeAttack, sSlimer, sSlimerDeath,sSlimerJump,sSlimerJumping,sSlimeAttackReturn,sBlank,sSlimeHurt,false,sSlimeHurt);

InitializeAISound(sndBlank,sndBlank,sndBlank,sndBlank);

InitializeAIStats(3, 0, 0, 0, 10, 5);

InitializeAIAbilities(oSlimeBall,sSlimeAttack,20);
//Attack timer is the time the AI waits between attacks.
AttackTimer = 30/(0.50*Speed);
//MovementTimer is the time the AI waits between moving one tile.
MovementTimer = 16/(0.50*Speed);


death = sSlimerDeath;
dead = sSlimerDead;

//AttackTime = BaseAttackTime/(0.25*Speed)
AttackTime = 24/(0.50*Speed);
//MovementTime = BaseMovementTime / (0.5*Speed);
MovementTime = 12/(0.5*Speed);
targetY = 0;
targetX = 0

jumpTimer = 0;
jumpX = gridX;
jumpY = 0;
jumpXPlace = 0;
jumpYPlace = 0;
jumpXStart = x;
jumpYStart = y;
jumpXPeak = 0;
jumpYPeak = 0;
jumpTimer = 0;


hurtTime = 0.5;
hurtTimer = 0;
landing = sSlimerLanding;
canTakeDamage[0] = "Hurt";
canTakeDamage[1] = "Hurting";
canTakeDamage[2] = "Idle";
canTakeDamage[3] = "Jump";
canTakeDamage[4] = "Attacking";
canTakeDamage[5] = "Return";
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch State
{
    case "Assess":
    // TO DO - CHOOSE A RANDOM TARGET FOR US TO SHOOT GOOB AT(CHECK THEIR CURRENTACTION VARIABLE AND TAKE THAT INTO ACCOUNT ASWELL)
        //Store all the relevant information about the potential targets in this loop
        ThreatArray = noone;
        var NumberOfCandidates, IndexThreat, target;
        NumberOfCandidates = 0;
        IndexThreat = 0;
        repeat(array_length_1d(oCursor.Party)){
            if instance_exists(oCursor.Party[IndexThreat]){
                //If the index exists, store the relevant information (BaseThreat,id,X coordinate,Y coordinate), and also add one to the count of how many target candidates we have.
                ThreatArray[NumberOfCandidates,0] = oCursor.Party[IndexThreat].Threat;
                ThreatArray[NumberOfCandidates,1] = oCursor.Party[IndexThreat].id;
                ThreatArray[NumberOfCandidates,2] = oCursor.Party[IndexThreat].gridX;
                ThreatArray[NumberOfCandidates,3] = oCursor.Party[IndexThreat].gridY;
                NumberOfCandidates += 1;
            }
            IndexThreat += 1;
        }
        
        if(ThreatArray != noone)
        {
            var targetIndex;
            targetIndex = irandom(NumberOfCandidates-1);
            
            target = ThreatArray[targetIndex,1];
            
            switch(target.currentAction)
            {
                case "Up":
                    targetY = target.gridY-1;
                    targetX = target.gridX;
                break;
                
                case "Down":
                    targetY = target.gridY+1;
                    targetX = target.gridX;
                break;
                
                case "Left":
                    targetY = target.gridY;
                    targetX = target.gridX-1;
                break;
                
                case "Right":
                    targetY = target.gridY;
                    targetX = target.gridX+1;
                break;
                
                default:
                    targetX = target.gridX;
                    targetY = target.gridY;
                break;
            }
            State = "Attacking";
        }
        else
        {
            AbilityTimer += 10;
            State = "Idle";
        }
    break;
    
    case "Jump":
        if sprite_index != Ability1Animation
        {
            //TO DO - DECIDE WHERE TO JUMP TO!!!!!!!"!!!!!"!#"
            JumpingBattle();
            SetAnimation(Ability1Animation);
        }
        Timer += DELTA_TIME;
        if(Timer &gt;= AnimationTime)
        {
            sprite_index = Ability2Animation;
            map[gridX,gridY].occupant = noone;
            gridX = jumpX;
            gridY = jumpY;
            State = "Jumping";
            
        }
    break;

    case "Idle":
        
        if AbilityCooldown &lt;= 0
        {
            State = "Assess";
        }
        
    break;
    
    case"Stunned":
    if sprite_index != Stunned{
        sprite_index = Stunned;
    }
    StunDuration -= DELTA_TIME;
    MovementTimer = MovementTime;
    AttackTimer = AttackTime;
    
    if StunDuration &lt;= 0{
        State = "Idle";
    
    
    } 
    
    break;
    
    case "Hurt":
        hurtTimer = hurtTime;
        sprite_index = Hurt;
        State = "Hurting";
    break;
    
    case "Hurting":
        hurtTimer -= DELTA_TIME;
        
        if(hurtTimer &lt;= 0)
        {
           State = "Jump"; 
        }
    break;
    
    case "Jumping":
        //TO DO - MOVE TOWARD JUMP PLACE BIOIOIOIOIPOIOPIOP
        jumpTimer += DELTA_TIME;
        
        
        if(jumpTimer+DELTA_TIME &gt; 1)
        {
            x = jumpXPlace;
            y = jumpYPlace;
            if map[gridX,gridY].occupant != noone
            {
                map[gridX,gridY].occupant.State = "Dead";
            }
            map[gridX,gridY].occupant = id;
            State = "Landing";
        }
        else
        {
            x = MoveInBezierCurve(jumpTimer,jumpXStart,jumpXPeak,jumpXPlace);
            y = MoveInBezierCurve(jumpTimer,jumpYStart,jumpYPeak,jumpYPlace);
        }
        
    break;
    
    case "Landing":
        //TO DO ~~~~~~Maybe have a landing animation play after landing on target tile
        if sprite_index != landing
        {
            SetAnimation(landing);
        }
        Timer += DELTA_TIME;
        if Timer &gt;= AnimationTime
        {
            State = "Idle";
            sprite_index = Idle;
        }
        
    break;
    
    case "Attacking":
        if sprite_index != Attack
        {
            SetAnimation(Attack);
        }
        Timer+=DELTA_TIME;
        
        if(Timer &gt;= AnimationTime)
        {
            var slime;
            slime = instance_create(x,y,Ability);
            slime.gridX = targetX;
            slime.gridY = targetY;
            slime.endY = map[targetX,targetY].y;
            slime.endX = map[targetX,targetY].x;
            slime.startX = x;
            slime.startY = y;
            slime.State = "PlanRoute";
            AbilityCooldown = AbilityCooldownMax;
            State = "Return";
        }
    break;
    
    case "Return":
        if sprite_index != Return
        {
            SetAnimation(Return);
        }
        Timer +=DELTA_TIME;
        if(Timer&gt;=AnimationTime)
        {
            sprite_index = Idle;
            State = "Idle";
        }
    break;
    
    case "Pause":
        GamePausedAI();
    break;
    
    case "Paused":
        image_index = AnimationFrame;
    break;
    
    case "UnPause":
        image_index = AnimationFrame;
        Timer = PreviousTimer;
        AttackTimer = AttackTimerPaused;
        MovemementTimer = MovementTimerPaused;
        State = PreviousState;
        AbilityCooldown = AbilityCooldownPaused;
    break;
    
    case"Dead":
        if deadest == false
        {
            if sprite_index != death
            {
                SetAnimation(death);
                map[gridX,gridY].occupant = noone;
                depth = 15;
                oBattleScreen.EncounterSize -= 1;
                AttackTimer = 10;
                sprite_index = DeathAnimation;
                MovementTimer = 10;
            }
            Timer +=DELTA_TIME;
            if Timer &gt;= AnimationTime
            {
                deadest = true;
                sprite_index = dead;
            }  
        }
        
        
    break;
}

AbilityCooldown -= DELTA_TIME;

SpriteShake();

if Damage &gt; 0{
    if State != "Dead"{
        audio_play_sound_on(oSFX.SFXEmitter,HurtSound,0,false);
        HitPoints -= floor(Damage*DamageMultiplier);
        State = "Hurt";
        Damage = 0;
        flashElapsed = flashTim;
        flash = 1;
        if HitPoints &lt;= 0{
            State = "Dead";
            if Owner = "Player"
            {
                ds_queue_clear(actionQueue);
                ds_list_clear(queuePainter.drawTable);
            }
        }
    }else{
        Damage = 0;
    }
    
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
