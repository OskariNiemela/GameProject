<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sMayorIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>oAi</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>InitializeBossEncounter();
InitializeAIStats(4,0,0,0,0,1);
InitializeAISound(sndBlank,sndBlank,sndBlank,sndBlank);
image_speed = 12*DELTA_TIME;



Moveset[0,0] = oTableFlip;
Moveset[0,1] = oJumpSmash;
Moveset[0,2] = oPowerbomb;

boi = noone;
Move = noone;
jump = false;

State = "Idle";

jumpTimer = 0;
startX = 0;
startY = 0;
endY = 0;
endX = 0;
midX = 0;
midY = 0;

Death = false;

WaitTime = 0;
WaitTimer = 0;

homeX = 12;
homeY = 4;

Bomb = sMayorPowerbomb;
Bombing = sMayorBombing;
Power = sMayorPowering;
BombingReturn = sMayorPowerbombReturn;
PowerbombFail = sMayorPowerbombMiss;
Smash = sMayorSmash;
SmashReturn = sMayorSmashReturn;
Jump = sMayorJump;
Jumping = sMayorAir;
Idle = sMayorIdle;
DeathAnimation = sMayorDeath;
Dead = sMayorDead;
PowerJump = sMayorPowerbombAir;
SmashJump = sMayorSmashAir;
FlipTable = sMayorTableflip;

returnAnimation = BombingReturn;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string> switch State{
    case "Deactive":
        sprite_index = Idle;
    break;

    case "Idle":
        WaitTimer +=DELTA_TIME;
        if(WaitTimer &gt;= WaitTime)
        {
            State = "ChoosePattern";
        }
        
    break;

    case "ChoosePattern":
        CurrentPatternIndex = irandom(array_height_2d(Moveset)-1);
        IndexOfAbility = 0;
        
        State = "ExecutePattern";
    break;
    
    case "ExecutePattern":
        
        if(IndexOfAbility &lt; array_length_2d(Moveset,CurrentPatternIndex))
        {
            CurrentAction = Moveset[CurrentPatternIndex,IndexOfAbility];
            //--------------------TO DO: Make mayor not target already powerbomber opponents with another powerbomb!!!!!!!!!!!-------------------------------//
            oMayorTarget();
            if(target != noone)
            {   
                State = "PatternAdvance";
            }
            else
            {
                State = "Idle";
                WaitTime = 5;
                WaitTimer = 0;
            }
        }
        else
        {
            State = "ChoosePattern";
        }
        
    break;
    
    
    case "PatternAdvance":
        CurrentAction = Moveset[CurrentPatternIndex,IndexOfAbility];
        IndexOfAbility += 1;
        State = "CheckAbility";
    break;
    
    case "CheckAbility":
        WaitBetweenAbilities -= DELTA_TIME;
        if WaitBetweenAbilities &lt;= 0
        {
            UseAbility = false;
            switch CurrentAction
            {
                case oPowerbomb:
                    State = "JumpTo";
                    WaitBetweenAbilities = 2;
                break;
                
                case oTableFlip:
                    State = "FlipTable";
                    WaitBetweenAbilities = 2;
                break;
                
                case oJumpSmash:
                    State = "JumpTo";
                    WaitBetweenAbilities = 2;
                break;
            }
        }
    break;
    
    case "JumpTo":
        if sprite_index != Jump
        {
            SetAnimation(Jump);
            jumpTimer = 0;
        }
        
        Timer += DELTA_TIME;
        if(Timer&gt;= AnimationTime)
        {
            
            if CurrentAction = oPowerbomb
            {
                switch target.currentAction
                {
                    case "Up":
                        if target.gridX+2 &lt; (13-2)
                        {
                            targetX = target.gridX+2;
                        }
                        else
                        {
                            image_xscale = -1;
                            targetX = target.gridX+2*sign(-image_xscale);
                        }
                        targetY = target.gridY-1;
                    break;
                    
                    case "Down":
                        if target.gridX+2 &lt; (13-2)
                        {
                            targetX = target.gridX+2;
                        }
                        else
                        {
                            image_xscale = -1;
                            targetX = target.gridX+2*sign(-image_xscale);

                        }
                        targetY = target.gridY+1;
                    break;
                    
                    case "Left":
                        if target.gridX+1 &lt; (13-2)
                        {
                            targetX = target.gridX+1;
                        }
                        else
                        {
                            image_xscale = -1;
                            targetX = target.gridX+3*sign(-image_xscale);
                            
                        }
                        targetY = target.gridY;
                    break;
                    
                    case "Right":
                        if target.gridX+3 &lt; (13-2)
                        {
                            targetX = target.gridX+3;
                        }
                        else
                        {   
                            image_xscale = -1;
                            targetX = target.gridX+1*sign(-image_xscale);
                            
                        }
                        targetY = target.gridY;
                    break;
                    
                    default:
                        if target.gridX+2 &lt; (13-2)
                        {
                            targetX = target.gridX+2;
                        }
                        else
                        {
                            image_xscale = -1;
                            targetX = target.gridX+2*sign(-image_xscale);
                        }
                        targetY = target.gridY;
                    break;
                }
            }
            else if CurrentAction = oJumpSmash
            {
                targetX = target.gridX;
                targetY = target.gridY;
                
            }
            
            startX = x;
            startY = y;
            endY = map[targetX,targetY].y;
            endX = map[targetX,targetY].x;
            
            
            GetBezierMid();
            map[gridX,gridY].occupant = noone;
            State = "Jumping";
            sprite_index = Jumping;
        }
        
        
    break;
    
    case "Jumping":
        jumpTimer += DELTA_TIME/1.2;
        
        
        if jumpTimer &gt;= 1
        {
            gridX = targetX;
            gridY = targetY;
            if instance_exists(map[gridX,gridY].occupant)
            {
                map[gridX,gridY].occupant.State = "Dead";
            }
            map[gridX,gridY].occupant = id;
            switch CurrentAction
            {
                case oPowerbomb:
                    State = "Powerbomb";
                    x = endX;
                    y = endY;
                break;
                
                case oJumpSmash:
                    State = "Jumpsmash";
                    x = endX;
                    y = endY;
                break;
                
                default:
                    State = "ExecutePattern";
                    sprite_index = Idle;
                    x = endX;
                    y = endY;
                break;
            }
        }
        else
        {
            x = MoveInBezierCurve(jumpTimer,startX,midX,endX);
            y = MoveInBezierCurve(jumpTimer,startY,midY,endY);
            //TO DO, IF JUMPTIMER &gt;= 0.5 THEN CHANGE THE JUMPING SPRITE ACCORDING TO THE CURRENT ACTION
            if jumpTimer &gt;= 0.2 and !jump
            {
                image_index = 0;
                switch CurrentAction 
                {
                    case oPowerbomb:
                        sprite_index = PowerJump;
                    break;
                    
                    case oJumpSmash:
                        sprite_index = SmashJump;
                    break;
                }
                jump = true;

            }
        }
        
        
        
    break;
    
    case "Powerbomb":
        if sprite_index != Bomb
        {
            SetAnimation(Bomb);
            boi = noone;
            jump = false;
            map[gridX,gridY].occupant = id;
        }
        Timer += DELTA_TIME;
        if(Timer &gt;= AnimationTime)
        {
            
            var found;
            found = false;
            //------------------------------- TO-DO: make powerbomb work only if the character isnt already powerbombed!!!!!!!!!!!!! ------------------------------------------------//
            while(!found)
            {
                for(a=-1;a&lt;2;a++)
                {
                    //
                    if((gridY+a &lt; 8) and (gridY+a&gt;0) and (gridX+1*sign(-image_xscale) &gt;= 0 )and gridX+1*sign(-image_xscale) &lt; 13)
                    {
                        if(instance_exists(map[gridX+1*sign(-image_xscale),gridY+a].occupant) and map[gridX+1*sign(-image_xscale),gridY+a].occupant.State != "Grounded")
                        {
                               map[gridX+1*sign(-image_xscale),gridY+a].occupant.Damage += Damage;
                               found = true;
                               boi = map[gridX+1*sign(-image_xscale),gridY+a].occupant;
                               break;
                        }
                    }
                
                }
                
                if found{
                    break;
                }
                
                //Check the second 3 tiles infront of us
                for(a=-1;a&lt;2;a++)
                {
                    if( (gridY+a &lt; 8) and (gridY+a&gt;0) and (gridX+2*sign(-image_xscale) &gt;= 0)and gridX+2*sign(-image_xscale) &lt; 13)
                    {
                        if(instance_exists(map[gridX+2*sign(-image_xscale),gridY+a].occupant)and map[gridX+2*sign(-image_xscale),gridY+a].occupant.State != "Grounded")
                        {
                               map[gridX+2*sign(-image_xscale),gridY+a].occupant.Damage += Damage;
                               found = true;
                               boi = map[gridX+2*sign(-image_xscale),gridY+a].occupant;
                               break;
                        }
                    }
                
                }
                
                if found{
                    break;
                }
                
                //Check the third 5 tiles infront of us
                for(a=-1;a&lt;2;a++)
                {
                    if ((gridY+a &lt; 8) and (gridY+a&gt;0) and (gridX+3*sign(-image_xscale)) &gt;= 0 and gridX+3*sign(-image_xscale) &lt; 13)
                    {
                        if(instance_exists(map[gridX+3*sign(-image_xscale),gridY+a].occupant)and map[gridX+3*sign(-image_xscale),gridY+a].occupant.State != "Grounded")
                        {
                               map[gridX+3*sign(-image_xscale),gridY+a].occupant.Damage += Damage;
                               found = true;
                               boi = map[gridX+3*sign(-image_xscale),gridY+a].occupant;
                               break;
                        }
                    }
               
                }
                break;
            }
            //Check the tiles infront of us, if there is an actor move them infront of us
            //and then create the powerbomb object and give it the needed information
            if found
            {
                map[boi.gridX,boi.gridY].occupant = noone;
                boi.gridX = gridX+1*sign(-image_xscale);
                boi.gridY = gridY;
                boi.x = map[gridX+1*sign(-image_xscale),gridY].x;
                boi.y = map[gridX+1*sign(-image_xscale),gridY].y;
                
                if instance_exists(map[gridX+1*sign(-image_xscale),gridY].occupant)
                {
                    var movable = map[gridX+1*sign(-image_xscale),gridY];
                    ExplodingTile = map[gridX+1*sign(-image_xscale),gridY];
                    var Neighbors, i, Neighbor;
                    NeighborsSize = ds_list_size(map[gridX,gridY].neighbors);
                    i = 0;
                    repeat(NeighborsSize){
                        Neighbor = ds_list_find_value(map[gridX,gridY].neighbors,i);
                        if !instance_exists(Neighbor.occupant){
                            ExplodingTile.occupant = noone;
                            Neighbor.occupant = movable;
                            movable.gridX = Neighbor.gridX;
                            movable.gridY = Neighbor.gridY;
                            movable.x = Neighbor.x;
                            movable.y = Neighbor.y;
                            break;
                        }
                        i++;
                        
                    }
                    if ExplodingTile.occupant == movable
                    {
                             movable.State = "Dead";
                    }
                }
                map[gridX+1*sign(-image_xscale),gridY].occupant = boi;
                ability = instance_create(boi.x,boi.y,oPowerbomb);
                ability.Target = boi;
                ability.Owner = id;
                ability.startX = boi.x;
                ability.startY = boi.y;
                ability.endY = y-100;
                ability.endX = x;
                ability.midY = y-50;
                ability.midX = boi.x+abs(x-boi.x)/2
                State = "Powering";
            
            }
            else
            {
                if image_xscale &lt; 0
                {
                    image_xscale = 1;
                }
                
                returnAnimation = PowerbombFail;
                State = "Return";
            }
        }
        
    break;
    
    case "Powering":
        if sprite_index != Power
        {
            SetAnimation(Power);
            ability.animationFrames = image_number;
            ability.animationTime = AnimationTime;
            ability.State = "PickUp";
            
        }
        Timer += DELTA_TIME;
        if(Timer&gt;=AnimationTime)
        {
            State = "Bombing";
        }
    break;
    
    case "Bombing":
        if sprite_index != Bombing
        {
            SetAnimation(Bombing);
            ability.animationFrames = image_number;
            ability.animationTime = AnimationTime;
            ability.moveTimer = 0;
            ability.State = "Target";
        }
        Timer += DELTA_TIME;
        
        if(Timer&gt;=AnimationTime)
        {
            returnAnimation = BombingReturn;
            State = "Return";
        }
    break;
    
    case "Jumpsmash":
        smash = instance_create(x,y,oJumpSmash);
        smash.gridX = targetX;
        smash.gridY = targetY;
        smash.State = "Smash";
        State = "Smash";
    break;
    
    case "Smash":
        if sprite_index != Smash
        {
            SetAnimation(Smash);
            jump = false;
        }
        Timer +=DELTA_TIME;
        
        if(Timer&gt;=AnimationTime)
        {
            returnAnimation = SmashReturn;
            State = "Return";
        }
    break;
        
    case "WaitingReturn":

    break;
    
    case "FlipTable":
        if sprite_index != FlipTable
        {
            SetAnimation(FlipTable);
            targetX = target.gridX;
            targetY = target.gridY;
        }
        Timer += DELTA_TIME;
        if (Timer &gt;= AnimationTime)
        {
            table = instance_create(x,y,oTableFlip);
            table.targetX = targetX;
            table.targetY = targetY;
            table.State = "Fly";
            returnAnimation = sMayorTableflipReturn;
            State = "ReturnNot";
        }
        
        
    break;
    
    case "ReturnNot":
        if sprite_index != returnAnimation{
            sprite_index = returnAnimation;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
            
        }
        Timer += DELTA_TIME;
        
        if Timer &gt;= AnimationTime
        {
            State = "ExecutePattern";
            sprite_index = Idle;
        }
    break;
    
    case "Return":
        if sprite_index != returnAnimation{
            sprite_index = returnAnimation;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
            
        }
        Timer += DELTA_TIME;
        
        if Timer &gt;= AnimationTime
        {
            State = "GetBack";
            CurrentAction = noone;
        }
    break;
    
    case "GetBack":
        if sprite_index != Jump
        {
            jumpTimer = 0;
            SetAnimation(Jump);
            startX = x;
            startY = y;
            endY = map[homeX,homeY].y;
            endX = map[homeX,homeY].x;
            GetBezierMid();
        }
        Timer += DELTA_TIME;
        if Timer &gt;= AnimationTime
        {
            map[targetX,targetY].occupant = noone;
            State = "Jumping";
            sprite_index = Jumping;
            targetX = homeX;
            targetY = homeY;
        }
    break;
    
    case "Waiting":
        sprite_index = Idle;
        WaitingTime -= DELTA_TIME;
        if WaitingTime &lt;= 0
        {
            State = "ChoosePattern";
        }
    
    break;
    
    case "Dead":
        if Death = false{
            if sprite_index != DeathAnimation{
                sprite_index = DeathAnimation;
                image_index = 0;
                AnimationTime = image_number*DELTA_TIME/image_speed;
                Timer = 0;
                
            }
            Timer += DELTA_TIME;
            
            if Timer &gt;= AnimationTime{
                sprite_index = Dead;
                image_index = 0;
                Death = true;
                oBattleScreen.EncounterSize = 0;
            }
        }
    break;
    
    
    case "Stunned":
        if IndexOfAbility &gt; 2{
            State = "ChoosePattern";
        }else{
            State = "ExecutePattern";
        }
    break;
}
TakeDamage();
//If we have been hit 
if Shake{
    
    ShakeTime += DELTA_TIME;
    if ShakeTime &lt; ShakeDuration{
        CurrentX = map[gridX,gridY].x;
        x = x + SpriteShakeAmount*(sign(ShakeDir)*(ShakeDuration-ShakeTime));
        ShakeDir = ShakeDir *(-1);
    }else{
        Shake = false;
        ShakeTime = 0;
        SpriteShakeAmount = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw_text(x,y-100,State);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
