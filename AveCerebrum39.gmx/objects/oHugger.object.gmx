<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sHugger</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>10</depth>
  <persistent>0</persistent>
  <parentName>oAi</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>InitializeAi("Enemy", "Magpie", "Melee", sFlamerAttack, sFlamer, sFlamerDeath,sBlank,sBlank,sFlamerAttackReturn,sBlank,sFlamerHurt,false,sMagpie);

InitializeAISound(sndBlank,sndBlank,sndBlank,sndBlank);

InitializeAIStats(3, 0, 0, 0, 10, 8);

InitializeAIAbilities(oTakeMeUp,sBlank,20);

//AI Stuff
Target = noone;
Assess = false;
//Attack timer is the time the AI waits between attacks.
AttackTimer = 30/(0.50*Speed);
//MovementTimer is the time the AI waits between moving one tile.
MovementTimer = 16/(0.50*Speed);


//AttackTime = BaseAttackTime/(0.25*Speed)
AttackTime = 24/(0.50*Speed);
//MovementTime = BaseMovementTime / (0.5*Speed);
MovementTime = 12/(0.5*Speed);

AbilityAnimation = sFlamerSpit;
abilityReturn = sFlamerSpitReturn;

Destination = noone;

EnemiesOnRow = false;

var i;
i = 0;
repeat(4){
    ThreatCandidates[i] = noone;
    i += 1;
}
//

ReturnAnim = sFlamerAttackReturn;

dead = sFlamerDead;
inAir = sPunchingBag;
land =  sPrideDeathBoss;
Grab = sMayorPowering;
missed = sBlankDeath;
grabbed = sSlimerJump;


ModHP = 0;
ModMAttack = 0;
ModSAttack = 0;
ModRAttack = 0;
ModSpeed   = 0;
ModAP      = 0;
ModCritStr = 0;

TargetXPositionDifference = 0;
TargetYPositionDifference = 0;

bezierTimer = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch(State){
    
    case "Idle":
    
    break;

    //Decide which player character is our target, so you can approach enemies/get on the same y level as enemies to shoot them.
    case"Assess":

        AssessThreatMelee();
        
        
        if instance_exists(Target)
        {
           AIMovementMelee();
        }
        else
        {
            MovementTimer = MovementTime;
            State = "Idle";
        }
        
    break;
    //Decide which way to move inorder to get to the most ideal placement to attack our target.
    case"Decide":
        
        
    break;
    
    case"Move":

    break;
    
    case"Stunned":
        if sprite_index != Stunned{
            sprite_index = Stunned;
        }
        StunDuration -= DELTA_TIME;
        MovementTimer = MovementTime;
        AttackTimer = AttackTime;
        
        if StunDuration &lt;= 0{
            State = "Idle";
        } 
    
    break;
    
    
    case"Attack":
        MeleeAttack(AttackStats,Attack);
        AttackTimer = AttackTime;
        ReturnAnimation = sFlamerAttackReturn;
    break;
    
    case"Flashing":
 
    break;
    
    /*
    case"Return":
        AttackReturnAnimAI();
    break;
    */
    
    case"Dead":
        if deadest == false
        {
            if sprite_index != DeathAnimation
            {
                map[gridX,gridY].occupant = noone;
                depth = 15;
                oBattleScreen.EncounterSize -= 1;
                AttackTimer = 10;
                SetAnimation(DeathAnimation);
                MovementTimer = 10;
            }
            Timer += DELTA_TIME;
            if Timer &gt;= AnimationTime
            {
                sprite_index = dead;
                deadest = true;
            }
        }
        
    break;
    
    case"Deactive":
        AttackTimer = 10;
        MovementTimer = 10;
    
    
    break;
    
    case"Pause":
        GamePausedAI();
    
    
    break;
    
    case"Paused":
        image_index = AnimationFrame;
        
    break;
    
    case"UseAbility":
        Target.targeted = true;
        AbilityCooldown = AbilityCooldownMax
        AbilityReady = false;
        if sprite_index != AbilityAnimation
        {
            SetAnimation(AbilityAnimation);
        }
        Timer += DELTA_TIME;
        startX = x;
        startY = y;
        midX = Target.x +(x-Target.x)/2;
        if(Target.y &gt;= y)
        {
            midY = y + (Target.y-y)/2;
        }
        else
        {
            midY = Target.y + (y-Target.y)/2;
        }
        
        endX = Target.x+20;
        endY = Target.y;
        
        targetX = Target.gridX;
        targetY = Target.gridY;
        
        State = "Jumpo";
    break;
    
    case "Jumpo":
        Timer += DELTA_TIME;
        if Timer &gt;= AnimationTime
        {
            map[gridX,gridY].occupant = noone;
            State = "Air";
            sprite_index = inAir;
            bezierTimer = 0;
        }
    break;
    
    case "Air":
        bezierTimer += DELTA_TIME;
        x = MoveInBezierCurve(bezierTimer,startX,midX,endX);
        y = MoveInBezierCurve(bezierTimer,startY,midY,endY);
        if(bezierTimer &lt;= 0.5)
        {
            targetX = Target.gridX;
            targetY = Target.gridY;
            endX = Target.x;
            endY = Target.y;
        }
        if(bezierTimer &gt;= 1)
        {
            x = endX;
            y = endY;
            State = "Grabbin";
        }
    break;
    
    case "Grabbin":
        if(sprite_index != Grab)
        {
            SetAnimation(Grab);
        }
        Timer += DELTA_TIME;
        if(Timer &gt;= AnimationTime)
        {
            if(map[targetX,targetY].occupant != noone)
            {
                abil = instance_create(map[targetX,targetY].occupant.x,map[targetX,targetY].y, oTakeMeUp);
                abil.owner = id;
                abil.target = map[targetX,targetY].occupant;
                abil.state = "Goin";
                State = "Grabbed";
            }
            else
            {
                State = "OhIMissed";
                x = map[targetX,targetY].x;
                y = map[targetX,targetY].y;
                map[targetX,targetY].occupant = id;
            }
        }
    break;
    
    case "OhIMissed":
        if(sprite_index != missed)
        {
            SetAnimation(missed);
        }
        Timer += DELTA_TIME;
        if(Timer &gt;= AnimationTime)
        {
            State = "GoBack";
        }
    break;
    
    case "GoBack":
        if(sprite_index != AbilityAnimation)
        {
            SetAnimation(AbilityAnimation);
        }
        Timer += DELTA_TIME;
        if(Timer &gt;= AnimationTime)
        {
            bezierTimer = 0;
            State = "AirBack";
            sprite_index = inAir;
        }
    
    break;
    
    case "AirBack":
        bezierTimer += DELTA_TIME;
        x = MoveInBezierCurve(bezierTimer,endX,midX,startX);
        y = MoveInBezierCurve(bezierTimer,endY,midY,startY);

        if(bezierTimer &gt;= 1)
        {
            Target = noone;
            x = startX;
            y = startY;
            State = "Land";
            if(instance_exists(map[gridX,gridY].occupant))
            {
                map[gridX,gridY].occupant.State = "Dead";
            }
        }
                
    break;
    
    case "Land":
        if(sprite_index != land)
        {
            SetAnimation(land);
        }
        Timer += DELTA_TIME;
        if(Timer &gt;= AnimationTime)
        {
            sprite_index = Idle;
            State = "Idle";
        }
        
    break;
    
    
    case "Grabbed":
        if(sprite_index != grabbed)
        {
            SetAnimation(grabbed);
        }
        Timer += DELTA_TIME;
        if(Timer &gt;= AnimationTime)
        {
            image_speed = 0;
            State = "GoUp";
        }
    break;
    
    case "GoUp":
        y -= 400/room_speed;
        if(y &lt;= -40)
        {
            abil.state = "Wait";
            State = "GoBack";
            endX = x;
            endY = y;
            midY = (startY - x)/2
        }
        
    break;
    
    case "Return":
        if sprite_index != ReturnAnim
        {
            SetAnimation(ReturnAnim);
        }
        Timer += DELTA_TIME;
        if Timer &gt;= AnimationTime
        {
            State = "Idle";
            sprite_index = Idle;
        }
    break;
    
    case"Unpause":
        image_index = AnimationFrame;
        Timer = PreviousTimer;
        AttackTimer = AttackTimerPaused;
        MovementTimer = MovementTimerPaused;
        State = PreviousState;
        AbilityCooldown = AbilityCooldownPaused;
    break;
}
if AbilityCooldown &lt;= 0 &amp;&amp; Target = noone{
    PickRandomTarget();
    //If we've no target, its no use trying to calculate values, so we just set both differences to 1.
    if(Target != noone)
    {
        TargetXPositionDifference = 0;
        TargetYPositionDifference = 0;
    }
    else
    {
        TargetXPositionDifference = 1;
        TargetYPositionDifference = 1;
    }
    
}
AIDecideMelee(TargetXPositionDifference,TargetYPositionDifference);
//Reduces the different timers that dictate when the AI can move, attack and use abilities.
ReduceAITimers();

TakeDamage();
SpriteShake();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
