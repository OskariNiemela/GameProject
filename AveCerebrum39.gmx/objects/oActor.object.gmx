<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*State = "Idle";

Owner = "Player";

gridX = 0;
gridY = 0;

name = "Error";

//Actor's attack 
Type = "Ranged";

Target = noone;

Shoot = false;

Melee = false;

//Actor's attackers stats
Attacker = noone;

DamageType = noone;

Hit = false;


//character statistics
Speed = 4

MaxAP = Speed;
AP = MaxAP;

MeleeAttack = 10;
SpecialAttack = 0;
RangedAttack = 10;
MeleeDefence = 0;
RangedDefence = 0;
CriticalStrikeChance = 0;

ModHP = 0;
ModMAttack = 0;
ModSAttack = 0;
ModRAttack = 0;
ModSpeed   = 0;
ModAP      = 0;
ModCritStr = 0;



MaxHitPoints = 10 + ModHP
HitPoints = MaxHitPoints


//Variable related to pathing
MovementPath = path_add();
path_set_kind(MovementPath, 2);
path_set_closed(MovementPath, false);

MoveSpeed = 220/room_speed;*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>depth = MaxDepth-gridY;
Actions();
if BodyIsWhole{
    switch State{
    
        case "Grounded":
            ds_queue_clear(actionQueue);
            currentAction = noone;
            with queuePainter
            {
                ds_list_clear(drawTable);
            }
            queueX = gridX;
            queueY = gridY;
        break;
                 
         case "Begin":
       
        break;   
    
    
         case  "Return":
            AttackReturnAnim();
        break;
        
        case"Attack":
            AttackTimer = AttackTime;
            switch Type{
                case "Ranged":
                    RangedAttack(ceil(random_range(MinAttack,AttackStats)*ModAttack),Attack,oBullet,1);
                break;
    
                case "Melee":
                    MeleeAttack(ceil(random_range(MinAttack,AttackStats)*ModAttack),Attack);
                break;
                
                case "MeleeArc":
                    MeleeArc(ceil(random_range(MinAttack,AttackStats)*ModAttack),Attack);
                break;
            }
        break;
        
        
        
        case "Attacking":
    
        break;
            
        case "Idle":
            if(sprite_index != Idle)
            {
                sprite_index = Idle;
            }
        break;
        
        case "Victory":
    
        
        break;
        
        case "Targeting":
            switch Move{
                case"Up":
                    if TargetedGridY &gt; 0{
                        TargetedGridY -= 1;
                    
                    }
                    Move = "No";
                
                break;
                
                case "Down":
                    if TargetedGridY &lt; oCursor.MapHeight{
                        TargetedGridY += 1;
                    }
                    Move = "No";
                break;
            
                
                case "Right":
                    if TargetedGridX &lt; oCursor.MapWidth{
                        TargetedGridX += 1;
                    }
                    Move = "No";
                break;
                
                case "Left":
                    if TargetedGridX &gt; 0{
                        TargetedGridX -= 1;
                    }
                    Move = "No";
                break;
            }
            if keyboard_check_pressed(vk_enter){
                State = "TargetedAbility";
            }
        
        break;
        
        case "TargetedAbility":
            if sprite_index != TargetedAbilityAnim{
                sprite_index = TargetedAbilityAnim;
                image_speed = AnimationSpeed;
                image_index = 0;
                AnimationTime = image_number*DELTA_TIME/image_speed;
                Timer = 0;
            }
            Timer += DELTA_TIME;
            if Timer &gt;= AnimationTime{
                TargetedAbility = instance_create(x,y,UsingAbility);
                TargetedAbility.TargetGridX = TargetedGridX;
                TargetedAbility.TargetGridY = TargetedGridY;
                State = "AbilityReturn";     
            }
        break;
        
        case "Hurt":
    
        break;
        
        case "TakingDamage":
    
        break;
        
        
        case "EndTurn":
    
        break;
    
        case "UsingAbility":
            if UsingAbility = Abilities[| 0]{
                effects_handler.using_effect = Abilities[| 0];
                AbilityCooldown1 = AbilityCooldown1Max;
                State = "AbilityAnimation";
                AbilityAnimation = Ability1Animation;
                AbilitySound = Ability1Sound;
                TargetedAbility = TargetedAbility1;
                TargetedAbilityAnim = TargetedAbilityAnims[0];
                AbilityReturnAnimation = Ability1ReturnAnimation;
            }else if UsingAbility = Abilities[| 1]{
                effects_handler.using_effect = Abilities[| 1];
                AbilityCooldown2 = AbilityCooldown2Max;
                State = "AbilityAnimation";
                AbilityAnimation = Ability2Animation;
                AbilitySound = Ability2Sound;
                TargetedAbility = TargetedAbility2;
                TargetedAbilityAnim = TargetedAbilityAnims[1];
                AbilityReturnAnimation = Ability2ReturnAnimation;
            }else if UsingAbility = Abilities[| 2]{
                effects_handler.using_effect = Abilities[| 2];
                AbilityCooldown3 = AbilityCooldown3Max;
                State = "AbilityAnimation";
                AbilityAnimation = Ability3Animation;
                AbilitySound = Ability3Sound;
                TargetedAbility = TargetedAbility3;
                TargetedAbilityAnim = TargetedAbilityAnims[2];
                AbilityReturnAnimation = Ability3ReturnAnimation;
            }
           
        
        break;
        
        case "AbilityAnimation":
            AbilityAnimations();
        break
        
        case "AbilityReturn":
            AbilityReturn();
        break;
        
        case "EvaluateMovement":
    
        break;
        
        case "Dead":
            // Make player portraits another variable somewhere so it can be universally used in this parent
            sprite_index = DeathAnimation;
            oBattleScreen.Players -= 1;
            map[gridX,gridY].occupant = noone;
            State = "Death";
            oCursor.Party[PartyNumber] = noone;
            HitPoints = 0;
            CharacterPortrait.Deactive = true;
            ds_list_add(oBattleScreen.DeadPlayers,id);
            currentAction = noone;
            ds_queue_clear(actionQueue);
            AbilityCooldown1 = 0;
            AbilityCooldown2 = 0;
            AbilityCooldown3 = 0;
        break;
        
        case "Resurrection":
            Resurrection();
            HitPoints = MaxHitPoints/2;
            CharacterPortrait.Deactive = false;
        break;
        
        case "Stunned":
            sprite_index = Stunned;
            StunDuration -= DELTA_TIME;
            if StunDuration &lt;= 0{
                State = "Idle";
            
            }
        break;
        
        case "UsingTeamAbility":
            
        
        break;
        
        case "TeamAbility":
        
        
        break;
        
        case "Pause":
            GamePause();
        break;
        
        case "Paused":
            image_index = AnimationFrame; 
        break;
        
        case"Unpause":
            State = PreviousState;
            image_index = AnimationFrame;
            Timer = PreviousTimer;
        break;
        
        case"Feared":
        
        
        break;
        
        
        case "Resurrect":
            if sprite_index != ReviveAnimation{
                sprite_index = ReviveAnimation;
                image_index = 0;
                AnimationTime = ResurrectTime;
                Timer = 0;
            }
            Timer += DELTA_TIME;
            if Timer &gt;= ResurrectTime{
                Resurrect = instance_create(x,y,oResurrect);
                Resurrect.Owner = id;
                State = "Idle";
                sprite_index = Idle;
            }
        break;
        
        case "Des":
        
        break;
    }
    ReduceTimers();
    
    Healing();
    
    TakeDamage();
    
    ReduceCooldowns();
    
    SpriteShake();
}else{
    if sprite_index != Feet{
        sprite_index = Feet;
        State = "Idle";
    }
    
    Move = "No";
    ds_queue_clear(actionQueue);
    currentAction = noone;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="8">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Clear path
/*
path_clear_points(MovementPath);
State = "Idle";

if(AP &gt; 0){
    oCursor.SelectedActor = id;
    movement_range(map[gridX, gridY], AP);    
}else{
    AP = MaxAP;
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_queue_destroy(actionQueue);

list = ds_map_find_first(abilityAnims);
des = abilityAnims[? list];

while(!is_undefined(list))
{
    if(ds_exists(des,ds_type_list))
    {
        list = ds_map_find_next(abilityAnims,list);
        ds_list_destroy(des);
        des = abilityAnims[? list];
    }
}

ds_map_destroy(abilityAnims);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_sprite_ext(sprite_index,image_index,round(x),round(y),1,1,image_angle,c_white,1);


if State = "Targeting"{
    draw_sprite(sTargeting,0,map[TargetedGridX,TargetedGridY].x,map[TargetedGridX,TargetedGridY].y);

}


if(flash&gt;0.0)
{
    if(flashElapsed&lt;=0.0)
    {
        flash -= 1.5*DELTA_TIME
    }
    else
    {
        
        flashElapsed -= DELTA_TIME;
    }
    
    shader_set(HurtShader);
    shaderAlpha = shader_get_uniform(HurtShader,"_alpha");
    shader_set_uniform_f(shaderAlpha,flash);
    
    draw_sprite_ext(sprite_index,image_index,round(x),round(y),1,1,image_angle,c_white,shaderAlpha);
    shader_reset();


}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
