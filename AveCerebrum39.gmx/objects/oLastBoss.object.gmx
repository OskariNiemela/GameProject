<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sFinalBossIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>InitializeBossEncounter();
InitializeAIStats(4,0,0,0,0,40);
InitializeAISound(sndBlank,sndBlank,sndBlank,sndBlank);
image_speed = 8*DELTA_TIME;
//Make different move patterns, from which the boss will randomly choose one
/*----------------Patterns-------------------*/
Moveset[0,0] = oLazor;
Moveset[0,1] = oLazor;
Moveset[0,2] = oLazor;
/*-------------------------------------------*/
State = "ChoosePattern";
/*-----------Animation----------------*/
charging = sPrideJump;
firing = sPridePissed;
lazorRet = sMayorSmash;
/*-------------------------------------*/
var i;
i = 0;

repeat(3){
    PatternCurrentlyExecuting[i] =  noone;
    i += 1;
}
CurrentPatternIndex = 2;
IndexOfAbility = 0;
UseAbility = false;


Death = false;

DestinationGridX = 0;
DestinationGridY = 0;
/*---------------------*/
firinTime = 1.5;
firinTimer = 0;

lefty = instance_create(x, y-400, oLastBossLeftArm);
lefty.owner = id;
lefty.gridY = 1
lefty.gridX = 10;
lefty.endY = id.y+100;
lefty.state = "Descent";
righty = instance_create(x, y-500, oLastBossLeftArm);
righty.endY = id.y-200;
righty.gridY = 6;
righty.gridX = 10;
righty.owner = id;
righty.TimeBetween = 2.5;
righty.state = "Descent";
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch State{
    case "Deactive":
        sprite_index = Idle;
    
    break;

    case "Idle":
        State = "ChoosePattern";
    break;

    case "ChoosePattern":
        var Index;
        Index = 0;
        CurrentPatternIndex = choose(0);
        IndexOfAbility = 0;
        
        State = "ExecutePattern";
    break;
    
    case "ExecutePattern":
        CurrentAction = Moveset[CurrentPatternIndex,IndexOfAbility];
        IndexOfAbility += 1;
        State = "CheckAbility";
    break;
    
    
    case "PatternAdvance":
        CurrentAction = Moveset[CurrentPatternIndex,IndexOfAbility];
        IndexOfAbility += 1;
        State = "CheckAbility";
    
    break;
    
    case "CheckAbility":
        WaitBetweenAbilities -= DELTA_TIME;
        if WaitBetweenAbilities &lt;= 0{
            UseAbility = false;
            switch CurrentAction{
                case oLazor:
                    State = "Charging";
                break;
           
                default:
                    if IndexOfAbility &gt; 2{
                        State = "ChoosePattern";        
                    }else{
                        State = "PatternAdvance";
                    }
                break;
            }
    }
    break;
   
    case "Charging":
        if sprite_index != sPrideJump
        {
            SetAnimation(sPrideJump);
        }
        Timer += DELTA_TIME;
        if Timer &gt;= AnimationTime
        {
            Lazer = instance_create(x,y,oLazor);
            Lazer.gridX = 11;
            Lazer.gridY = 3;
            Lazer.state = "FireUp";
            firinTimer = 0;
            State = "Firin";
        }
    break;
    
    case "Firin":
        if sprite_index != firing
        {
            sprite_index = firing;
        }
        firinTimer += DELTA_TIME;
        if(firinTimer &gt;= firinTime)
        {
            Lazer.state = "WindDown";
            State = "Return";
            ReturningAnimation = lazorRet;
        }
    break;
    
    
    case "Return":
        /*
        if sprite_index != ReturningAnimation{
            sprite_index = ReturningAnimation;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
        }
        Timer += DELTA_TIME;
        
        if Timer &gt;= AnimationTime{
            
            if IndexOfAbility &gt; 2{
                State = "ChoosePattern";
                
            }else{
                State = "ExecutePattern";
                
            } 
        
        }
        */
    break;
    
    
    case "Waiting":
        sprite_index = Idle;
        WaitingTime -= DELTA_TIME;
        if WaitingTime &lt;= 0{
            State = "ChoosePattern";
        }
    
    break;
    
    case "Dead":
        if Death = false{
            if sprite_index != DeathAnimation{
                sprite_index = DeathAnimation;
                image_index = 0;
                AnimationTime = image_number*DELTA_TIME/image_speed;
                Timer = 0;
            }
            Timer += DELTA_TIME;
            
            if Timer &gt;= AnimationTime{
                sprite_index = Dead;
                image_index = 0;
                Death = true;
            }
        }
    break;
    
    
    case "Stunned":
        if IndexOfAbility &gt; 2{
            State = "ChoosePattern";
        }else{
            State = "ExecutePattern";
        }
    break;
    
    case "Paused":
        if (oBert.State = "Idle")
        {
            State = "Idle";
        }
    break;
}
if(Damage &gt; 0 )
{
    if(lefty.state == "Idle")
    {
        Damage = 0;
        lefty.state = "Block";
    }
    else if (righty.state = "Idle")
    {
        Damage = 0;
        righty.state = "Block";
    }
    else
    {
        TakeDamage();
    }

}

//If we have been hit 
if Shake{
    
    ShakeTime += DELTA_TIME;
    if ShakeTime &lt; ShakeDuration{
        CurrentX = map[gridX,gridY].x;
        x = CurrentX + SpriteShakeAmount*(sign(ShakeDir)*(ShakeDuration-ShakeTime));
        ShakeDir = ShakeDir *(-1);
    }else{
        Shake = false;
        ShakeTime = 0;
        SpriteShakeAmount = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_text(10,80,State);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
