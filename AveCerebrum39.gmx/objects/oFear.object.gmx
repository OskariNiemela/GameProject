<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sFearBasic</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>oAi</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>InitializeBossEncounter();
InitializeAIStats(4,0,0,0,0,40);
InitializeAISound(sndBlank,sndBlank,sndBlank,sndBlank);
image_speed = 8*DELTA_TIME;
//Make different move patterns, from which the boss will randomly choose one
/*----------------Patterns-------------------*/
Moveset[0,0] = oDecapitate;
Moveset[0,1] = oFireSprite;
Moveset[0,2] = oScytheThrow;

Moveset[1,0] = oHeadThrow;
Moveset[1,1] = oDecapitate;
Moveset[1,2] = oScytheThrow;

Moveset[2,0] = oGroundSlice;
Moveset[2,1] = oHeadThrow;
Moveset[2,2] = oDecapitate;
/*-------------------------------------------*/

State = "ChoosePattern";
/*-----------Animation----------------*/
//Teleporting
Teleport = sFearTeleport;
TeleportIn = sFearAppear;
Fly = sScytheThrow;
//Melee
MeleeAnimation = sFearMelee;
MeleeReturn = sFearMeleeReturn;
//HeadThrow
HeadThrow = sFearPickUpHead;
HeadThrowWindUp = sFearWindUp;
WaitForHead = sFearHeadWait;
//ScytheThrow
ScytheThrow = sFearScytheThrow;
WaitForScythe = sFearScytheWait;
//Decapitation
Appear = sFearAppearDecap;
Decapitate = sFearDecapitate;
TeleportDecap = sFearTeleportDecap;
//Portal
SummonPortals = sFearSummonPortal;
PortalReturn = sFearPortalReturn;
//Death
DeathAnimation = sFearDeath;
Dead = sFearDead;
//GroundSlice
GroundSlice = sFearGroundSlice;
GroundSliceReturn = sFearGroundSliceReturn;

SummonSprites = sFearSummonPortal;
SpritesReturn = sFearPortalReturn;

Idle = sFearStandby;
/*-------------------------------------*/
var i;
i = 0;

repeat(3){
    PatternCurrentlyExecuting[i] =  noone;
    i += 1;
}
CurrentPatternIndex = 2;
IndexOfAbility = 0;
UseAbility = false;


Death = false;

//Flying variables
FlyAwayX = room_width;
FlyAwayY = 0;
FlightSpeed = 1200*DELTA_TIME;

WaitBetweenAbilities = 0;

FlyingAway = false;

DestinationGridX = 0;
DestinationGridY = 0;
/*---------------------*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch State{
    case "Deactive":
        sprite_index = Idle;
    
    break;

    case "Idle":
        State = "ChoosePattern";
    break;

    case "ChoosePattern":
        var Index;
        Index = 0;
        if instance_exists(oPortal){
            CurrentPatternIndex = choose(1,2);
        }else{
            CurrentPatternIndex = choose(0);
        }
        IndexOfAbility = 0;
        
        State = "ExecutePattern";
    break;

    case "TeleportOut":
        oFearTeleport();
    break;
    
    case "TeleportIn":
        oFearTeleportIn()
    break;
    
    
    case "FlyAway":
        /*-----------------Fly up and out of view------------------*/
        if FlyingAway = false{
            
            Direction = point_direction(x,y,FlyAwayX,FlyAwayY); 
            Distance = point_distance(x,y,FlyAwayX,FlyAwayY);
            FlightTime = (Distance*DELTA_TIME)/FlightSpeed;
            FlyingAway = true;
        }
        direction = Direction;
        speed = FlightSpeed;
        FlightTime -= DELTA_TIME;
        //Once we're done flying away, choose our next State by looking at our CurrentAction
        if FlightTime &lt;= 0{
            sprite_index = Idle;
            speed = 0;
            direction = 0;
            State = "CheckAbility";
            FlyingAway = false;
        }
        
    break;
    
    case "ExecutePattern":
        CurrentAction = Moveset[CurrentPatternIndex,IndexOfAbility];
        oFearSelectTarget();
        IndexOfAbility += 1;
        State = "TeleportOut";
    break;
    
    
    case "PatternAdvance":
        CurrentAction = Moveset[CurrentPatternIndex,IndexOfAbility];
        oFearSelectTarget();
        IndexOfAbility += 1;
        State = "FlyAway";
    
    break;
    
    case "CheckAbility":
        WaitBetweenAbilities -= DELTA_TIME;
        if WaitBetweenAbilities &lt;= 0{
            UseAbility = false;
            switch CurrentAction{
                case oScytheThrow:
                    CheckTargetTile(false,3,0)
                    //Fly two tiles infront of our target(If we cant , then choose another target, if no actors are legible, just skip this ability)
                    if UseAbility{
                        StateToGoTo = "ThrowingScythe";
                        State = "TeleportIn";
                    
                    }else{
                        if IndexOfAbility &gt; 2{
                            State = "ChoosePattern";
                        }else{
                            State = "PatternAdvance";
                        } 
                    }
                break;
           
            
                case oPortal:
                    CheckTargetTile(true,10,4)
                    // Appear on a specific tile on the map and summon portals(if tile is not free, try one tile up from it, if that is not open try one tile down from the original tile, if that is not open try two tiles up.
                    if UseAbility {
                            StateToGoTo = "SummonPortals";
                            State = "TeleportIn";
                        }else{
                            if IndexOfAbility &gt; 2{
                                State = "ChoosePattern";
                                
                            }else{
                                State = "PatternAdvance";
                            } 
                        }
                
                break;
            
                case oGroundSlice:
                    CheckTargetTile(true,11,Target.gridY);
                    if UseAbility{
                        StateToGoTo = "GroundSlice";
                        State = "TeleportIn";
                    }else{
                        if IndexOfAbility &gt; 2{
                            State = "ChoosePattern";
                                
                        }else{
                            State = "PatternAdvance";
                        } 
                    }
            
            
                break;
            
                case oHeadThrow:
                    CheckTargetTile(true,10,4)
                    if UseAbility{
                        StateToGoTo = "ThrowHead";
                        State = "TeleportIn";
                    }else{
                        if IndexOfAbility &gt; 2{
                            State = "ChoosePattern";
                                
                        }else{
                            State = "PatternAdvance";
                        } 
                    }
            
                break;
            
                case oDecapitate:
                    if Target.BodyIsWhole and Target.State != "Death"{
                        State = "TeleportInDecap";
                    }else{
                        if IndexOfAbility &gt; 2{
                            State = "ChoosePattern";
                                
                        }else{
                            State = "PatternAdvance";
                        } 
                    }
                break;
                
                case oFireSprite:
                    CheckTargetTile(true,12,4)
                    if UseAbility {
                            StateToGoTo = "SummonSprites";
                            State = "TeleportIn";
                        }else{
                            if IndexOfAbility &gt; 2{
                                State = "ChoosePattern";
                            }else{
                                State = "PatternAdvance";
                            } 
                        }
                break;
            
                default:
                    if IndexOfAbility &gt; 2{
                        State = "ChoosePattern";        
                    }else{
                        State = "PatternAdvance";
                    }
                break;
            }
    }
    break;
    
    case "GroundSlice":
        if sprite_index != MeleeAnimation{
            //Start the indicator for all the tiles directly infront of the boss
            sprite_index = MeleeAnimation;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
            var Index;
            Index = 1;
            /*
            for(i=0;i&lt;oCursor.MapWidth;i+=1){
                if gridX-Index &gt;= 0{
                    map[gridX-Index,gridY].Blinking = true;
                }else{
                    break;
                }
                Index += 1;
            }
            */
        }
        Timer += DELTA_TIME;
    
        if Timer &gt;= AnimationTime{
            var Neighbors, i, Neighbor;
            NeighborsSize = ds_list_size(map[gridX,gridY].neighbors);
            i = 0;
            repeat(NeighborsSize){
               Neighbor = ds_list_find_value(map[gridX,gridY].neighbors,i);
               if instance_exists(Neighbor.occupant) and Neighbor.occupant.Owner != Owner{
                    GiveDamage(Neighbor.occupant,AttackStat,5);
               }
               i += 1;
            }
            State = "GroundSlicing";
        }
    
    break;
        
    case "GroundSlicing":
        if sprite_index != GroundSlice{
            sprite_index = GroundSlice;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
        }
        Timer += DELTA_TIME;
        if Timer &gt;= AnimationTime{
            //Stop the blinking of the tiles and spawn the oGroundSlice object, which will take it from here
            GroundSlice = instance_create(map[gridX-1,gridY].x,map[gridX-1,gridY].y,oGroundSlice);
            GroundSlice.gridX = gridX-1;
            GroundSlice.gridY = gridY;
            var Index;
            Index = 1;
            /*
            for(i=0;i&lt;oCursor.MapWidth;i+=1){
                if gridX-Index &gt;= 0{
                    map[gridX-Index,gridY].Blinking = false;
                    map[gridX-Index,gridY].Blink = false;
                    map[gridX-Index,gridY].BlinkTimer = 0;
                }else{
                    break;
                }
                Index += 1;
            }
            */
            ReturningAnimation = GroundSliceReturn;
            State = "Return";
        }
    break;
    
    
    case "ThrowHead":
        //First play the animation of the boss picking up its own head and getting into position to throw it
        if sprite_index != HeadThrow{
            sprite_index = HeadThrow;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
    
        }
        Timer += DELTA_TIME;
        
        if Timer &gt;= AnimationTime{
            //change 
            HeadThrowGridX = Target.gridX;
            HeadThrowGridY = Target.gridY;
            State = "ThrowingHead";
        }
    break;
    
    case "ThrowingHead":
        if sprite_index != HeadThrowWindUp{
            //make the targeted tiles blink to indicate danger
            map[HeadThrowGridX,HeadThrowGridY].Blinking = true;
            var Neighbors, i, Neighbor;
            NeighborsSize = ds_list_size(map[HeadThrowGridX,HeadThrowGridY].neighbors);
            i = 0;
            repeat(NeighborsSize){
               Neighbor = ds_list_find_value(map[HeadThrowGridX,HeadThrowGridY].neighbors,i);
               Neighbor.Blinking = true;
               i += 1;
            }
            sprite_index = HeadThrowWindUp;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
    
        }
        Timer += DELTA_TIME;
        
        if Timer &gt;= AnimationTime{
            WaitBetweenAbilities = 2;
            map[HeadThrowGridX,HeadThrowGridY].Blink = false;
            map[HeadThrowGridX,HeadThrowGridY].Blinking = false;
            map[HeadThrowGridX,HeadThrowGridY].BlinkTimer = 0;
            var Neighbors, i, Neighbor;
            NeighborsSize = ds_list_size(map[HeadThrowGridX,HeadThrowGridY].neighbors);
            i = 0;
            repeat(NeighborsSize){
               Neighbor = ds_list_find_value(map[HeadThrowGridX,HeadThrowGridY].neighbors,i);
               Neighbor.Blinking = false;
               Neighbor.Blink = false;
               Neighbor.BlinkTimer = 0;
               i += 1;
            }
            FlyingHead =  instance_create(x,y,oHeadThrow);
            FlyingHead.DestinationGridX = HeadThrowGridX;
            FlyingHead.DestinationGridY = HeadThrowGridY;
            FlyingHead.Owner = id;
            sprite_index = WaitForHead;
            State = "WaitingReturn";
        }
    
    
    break;
    
    
    
    case "WaitingReturn":

    break;
    
    case "Return":
        if sprite_index != ReturningAnimation{
            sprite_index = ReturningAnimation;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
        }
        Timer += DELTA_TIME;
        
        if Timer &gt;= AnimationTime{
            
            if IndexOfAbility &gt; 2{
                State = "ChoosePattern";
                
            }else{
                State = "ExecutePattern";
                
            } 
        
        }
    break;
    
    case "SummonSprites":
        if sprite_index != SummonSprites{
            sprite_index = SummonSprites;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
        }
        Timer += DELTA_TIME;
        
        if Timer &gt;= AnimationTime{
            WaitBetweenAbilities = 2;
            //Create sprites
            var GridXSummon, GridYSummon;
            GridXSummon = 12;
            GridYSummon = 2;
            Sprite1 = instance_create(map[GridXSummon,GridYSummon].x,map[GridXSummon,GridYSummon].y,oFireSprite);
            Sprite1.gridX = GridXSummon;
            Sprite1.gridY = GridYSummon;

            GridYSummon = 4;
            Sprite2 = instance_create(map[GridXSummon,GridYSummon].x,map[GridXSummon,GridYSummon].y,oFireSprite);
            Sprite2.gridX = GridXSummon;
            Sprite2.gridY = GridYSummon;
            GridYSummon = 6;
            Sprite3 = instance_create(map[GridXSummon,GridYSummon].x,map[GridXSummon,GridYSummon].y,oFireSprite);
            Sprite3.gridX = GridXSummon;
            Sprite3.gridY = GridYSummon;
            
            
            
            ReturningAnimation = SpritesReturn;
            State = "Return";
        }
    break;
    
    case "SummonPortals":
    //Appear in the middle of the map and summon two portals at the right locations;
        if sprite_index != SummonPortals{
            sprite_index = SummonPortals;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
        }
        Timer += DELTA_TIME;
        
        if Timer &gt;= AnimationTime{
            WaitBetweenAbilities = 1;
            //Create Portals
            var Portal1, Portal2;
            Portal1 = instance_create(x,y,oPortalCreator);
            Portal1.DestinationGridX = 10;
            Portal1.DestinationGridY = 2
            Portal2 = instance_create(x,y,oPortalCreator);
            Portal2.DestinationGridX = 10;
            Portal2.DestinationGridY = 6
            
            ReturningAnimation = PortalReturn;
            State = "Return";
        }
    break;
    
    case "ThrowingScythe":
        //Appear in front of our target and throw our scythe
        if sprite_index != ScytheThrow{
            sprite_index = ScytheThrow;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
        
        }
        Timer += DELTA_TIME;
        
        if Timer &gt;= AnimationTime{
            WaitBetweenAbilities = 1;
            Scythe = instance_create(x,y,oScytheThrow);
            Scythe.Owner = id;
            sprite_index = WaitForScythe;
            State = "WaitingReturn";
        }
        
    break;
    
    case "MeleeAttack":
    //Appear next to our target and melee attack
        MeleeAttack(AttackStats,MeleeAnimation);
        ReturningAnimation = MeleeReturn;
        State = "Return";
    break;
    
    case "TeleportInDecap":
        x = Target.x-40;
        y = Target.y;
        if sprite_index != Appear{
            sprite_index = Appear;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
        }
        Timer += DELTA_TIME;
        if Timer &gt;= AnimationTime{
            State = "Decapitating";
        }
    
    break;
    
    case "Decapitating":
    x = Target.x-40;
    y = Target.y;

        //Execute the Decapitate ability
    if sprite_index != Decapitate{
        sprite_index = Decapitate;
        image_index = 0;
        AnimationTime = image_number*DELTA_TIME/image_speed;
        Timer = 0;
    }
    Timer += DELTA_TIME;
            
    if Timer &gt;= AnimationTime{
        WaitBetweenAbilities = 5000;
        DecapitationAbility = instance_create(x,y,oDecapitate);
        DecapitationAbility.Owner = Target;
        if IndexOfAbility &gt; 2{
            State = "ChoosePatternDecap";      
        }else{
            State = "ExecutePatternDecap";           
        }
    }
    
    
    break;
    
    case "ExecutePatternDecap":
        CurrentAction = Moveset[CurrentPatternIndex,IndexOfAbility];
        oFearSelectTarget();
        IndexOfAbility += 1;
        State = "TeleportOutDecap";
    break;
    
    
    case "ChoosePatternDecap":
        if instance_exists(oPortal){
            CurrentPatternIndex = choose(1,2);
        }else{
            CurrentPatternIndex = choose(0);
        }
        IndexOfAbility = 0;
        State = "ExecutePatternDecap";
    break;
    
    
    case "TeleportOutDecap":
        if sprite_index != TeleportDecap{
            sprite_index = TeleportDecap;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
            }
            Timer += DELTA_TIME;
            
            if Timer &gt;= AnimationTime{
                sprite_index = Fly;
                State = "FlyAway";
            }
    break;
    
    
    case "Waiting":
        sprite_index = Idle;
        WaitingTime -= DELTA_TIME;
        if WaitingTime &lt;= 0{
            State = "ChoosePattern";
        }
    
    break;
    
    case "ReattachHead":
        if sprite_index != HeadCatch{
            sprite_index = HeadCatch;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
        }
        Timer += DELTA_TIME;
        if Timer &gt;= AnimationTime{
            if IndexOfAbility &gt; 2{
                State = "ChoosePattern";
            }else{
                State = "ExecutePattern";
            }
            
        }
    break;
    
    
    case "Dead":
        if Death = false{
            if sprite_index != DeathAnimation{
                sprite_index = DeathAnimation;
                image_index = 0;
                AnimationTime = image_number*DELTA_TIME/image_speed;
                Timer = 0;
            }
            Timer += DELTA_TIME;
            
            if Timer &gt;= AnimationTime{
                sprite_index = Dead;
                image_index = 0;
                Death = true;
            }
        }
    break;
    
    
    case "Stunned":
        if IndexOfAbility &gt; 2{
            State = "ChoosePattern";
        }else{
            State = "ExecutePattern";
        }
    
    
    break;
}
TakeDamage();
//If we have been hit 
if Shake{
    
    ShakeTime += DELTA_TIME;
    if ShakeTime &lt; ShakeDuration{
        CurrentX = map[gridX,gridY].x;
        x = CurrentX + SpriteShakeAmount*(sign(ShakeDir)*(ShakeDuration-ShakeTime));
        ShakeDir = ShakeDir *(-1);
    }else{
        Shake = false;
        ShakeTime = 0;
        SpriteShakeAmount = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
