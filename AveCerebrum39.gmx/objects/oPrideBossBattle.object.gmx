<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sPrideBOSSLeft</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>oAi</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>InitializeBossEncounter();
InitializeAIStats(4,0,0,0,0,28);
InitializeAISound(sndBlank,sndBlank,sndBlank,sndBlank);
image_speed = 12*DELTA_TIME;

Moveset[0,0] = oSummonGoons;

boi = noone;
Move = noone;
target = noone;
pissed = false;

pissedTime = 0;

State = "Idle";

dashSpeed = 600;

jumpTimer = 0;
startX = 0;
startY = 0;
endY = 0;
endX = 0;
midX = 0;
midY = 0;

Death = false;

goBack = false;

WaitTime = 0;
WaitTimer = 0;

homeX = 12;
homeY = 4;

Idle = sPrideBOSSLeft;
Dash = sPrideDash;
Windup = sPrideWindUp;
Summon = sPrideSummon;
SummonReturn = sPrideSummonReturn;
Hit = sPrideHit;
Miss = sPrideMiss;
Punch = sPridePunch;
Jump = sPrideJump;
Jumping = sPrideJumping;
Landing = sPrideLand;
Pissed = sPridePissed;
Attack = sPrideAttackBoss;
AttackReturn = sPrideAttackBossReturn;
Dead = sPrideDeathBoss;
DeathAnimation = sPrideDeathBoss;

AttackTime = 5/10;
MovementTime = 5/10;

partSys = part_system_create();

steamEf = part_type_create();
part_type_sprite(steamEf,sSteam,0,0,1);
part_type_color1(steamEf,c_white);
part_type_alpha2(steamEf,1,0);
part_type_blend(steamEf,false);
part_type_direction(steamEf,90,80,0,2);
part_type_size(steamEf,1,1.1,0.1,0.05);
part_type_life(steamEf,room_speed,room_speed*1.5);
part_type_orientation(steamEf,0,0,0,3,0);
part_type_speed(steamEf,150/room_speed,150/room_speed,-0.02,0);

steamEmitter = part_emitter_create(partSys);



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>speed = 0;

switch State{
    case "Deactive":
        sprite_index = Idle;
    break;

    case "Idle":
        WaitTimer += DELTA_TIME;
        sprite_index = Idle;
        if WaitTimer &gt;= WaitTime
        {
            if(!pissed)
            {
                AttackTimer +=DELTA_TIME;
                if(AttackTimer &gt;= AttackTime)
                {
                    image_speed = 12*DELTA_TIME;
                    image_index = sPrideBOSSLeft;
                    State = "ChoosePattern";
                }
            }
            else
            {   
                image_speed = 18*DELTA_TIME;
                
                oPrideTarget();
                State = "Pissing";
            }
        }
        
        
        
    break;
    
    case "Pissing":
        if sprite_index != Pissed
        {
            sprite_index = Pissed
            image_index = 0;
            Timer = 0;
            image_speed = 18*DELTA_TIME;
            AnimationTime = image_number*DELTA_TIME / image_speed;
        }
        Timer += DELTA_TIME;
        if Timer &gt;= AnimationTime
        {
            State = "Move";
        }
    break;
    
    case "Move":
        MovementTimer += DELTA_TIME;
        
        if sprite_index != sPridePissedWalk
        {
            sprite_index = sPridePissedWalk;
        }        
        
        if target != noone
        
        {
            if MovementTimer&gt;=MovementTime
            {
                     //if our target is right infront of us, dont do anything just wait.
            if  abs(target.gridY-gridY) &lt;= 0 and abs(target.gridX-gridX) &lt;= 1{
                    MovementTimer = 0;
                    //State = "Idle";
            
            }
            
            //If our target is on our Y plane(+1)
            else if abs(target.gridY-gridY) &lt;= 1{
                //Check whether the target is on our left or on our right
                if target.gridX &gt; gridX{
                    if map[gridX+1,gridY].occupant = noone{
                        MoveXMelee(1);
                    }
                }else {
                     if map[gridX-1,gridY].occupant = noone{
                        MoveXMelee(-1);
                    }
                }
                        //If we cant move one Y up (something is blocking us from doing so) move one X to either side
                
                }
                //If our target is on our X plane(+1)
                else if abs(target.gridX-gridX) &lt;= 1{
                    //Check whether our target is up or down from us
                    if target.gridY &gt; gridY{
                        if map[gridX,gridY+1].occupant = noone{
                            MoveYMelee(1);
                        }
                    }else{
                        if map[gridX,gridY-1].occupant = noone{
                            MoveYMelee(-1);
                        }
                    
                    
                    }
                
                }
                //If our target is on neither
                else if instance_exists(target) {
                    //If our target is down from us and to the left
                    if target.gridY &gt; gridY and target.gridX &lt; gridX{
                        if LastDirectionWeMovedIn ="HZ" or LastDirectionWeMovedIn = "n/a"{
                            if map[gridX,gridY+1].occupant = noone{
                                MoveYMelee(1);
                            }
                        
                        }else{
                            if map[gridX-1,gridY].occupant = noone{
                                MoveXMelee(-1);
                            
                            }
                        
                        
                        
                        }
                    
                    }
                    //If our target is down from us and to the right
                    if target.gridY &gt; gridY and target.gridX &gt; gridX{
                        if LastDirectionWeMovedIn ="HZ" or LastDirectionWeMovedIn = "n/a"{
                            if map[gridX,gridY+1].occupant = noone{
                                MoveYMelee(1);
                            }
                        
                        
                        }else{
                             if map[gridX+1,gridY].occupant = noone{
                                MoveXMelee(1);
                            
                            }
                        
                        
                        }
                    
                    }
                    //If our target is up from us and to the left
                    if target.gridY &lt; gridY and target.gridX &lt; gridX{
                        if LastDirectionWeMovedIn ="HZ" or LastDirectionWeMovedIn = "n/a"{
                            if map[gridX,gridY-1].occupant = noone{
                                MoveYMelee(-1);
                            }
                        
                        
                        }else{
                            if map[gridX-1,gridY].occupant = noone{
                                MoveXMelee(-1);
                            
                            }
                        
                        
                        }
                    
                    }
                    //If our target is up from us and to the right
                    if target.gridY &lt; gridY and target.gridX &gt; gridX{
                        if LastDirectionWeMovedIn ="HZ" or LastDirectionWeMovedIn = "n/a"{
                            if map[gridX,gridY-1].occupant = noone{
                                MoveYMelee(-1);
                            }
                        
                        
                        }else{
                            if map[gridX+1,gridY].occupant = noone{
                                MoveXMelee(1);
                            
                            }
                        
                        
                        }
                    
                    }
                    }
                    MovementTimer = 0;
                    
            }
            if abs(target.gridX-gridX) &lt;=1 and abs(target.gridY - gridY) &lt;= 1
            {
                State = "Attack";
            }
        }
        else
        {
            oPrideTarget();
        }
    break;
    
    case "Attack":
        if sprite_index != Attack
        {
            //SetAnimation(Attack);
            sprite_index = Attack
            image_index = 0;
            Timer = 0;
            image_speed = 18*DELTA_TIME;
            AnimationTime = image_number*DELTA_TIME / image_speed;
            
        }
        Timer += DELTA_TIME;
        if(Timer&gt;=AnimationTime)
        {
            var myTile;
            myTile = map[gridX,gridY];
            var Neighbors, i, Neighbor;
            NeighborsSize = ds_list_size(map[gridX,gridY].neighbors);
            i = 0;
            repeat(NeighborsSize){
               Neighbor = ds_list_find_value(map[gridX,gridY].neighbors,i);
               if instance_exists(Neighbor.occupant){
                    Neighbor.occupant.Damage += AttackStats;
                    Neighbor.occupant.Shake  = true;
                    Neighbor.occupant.SpriteShakeAmount = 5;
                    Neighbor.occupant.ShakeTime =   0;
                }
                i += 1;
            }
            State = "AttackReturn";
            returnAnimation = AttackReturn;
        }
    break;
    
    case "AttackReturn":
        if sprite_index != AttackReturn
        {
            sprite_index = AttackReturn;
            image_index = 0;
            Timer = 0;
            image_speed = 18*DELTA_TIME;
            AnimationTime = image_number*DELTA_TIME/image_speed;
        }
        Timer += DELTA_TIME;
        if(Timer&gt;=AnimationTime)
        {
            State = "Move";
        }
        
    break;
    
    
    case "ChoosePattern":
        CurrentPatternIndex = choose(0);
        CurrentPatternIndex = irandom(array_height_2d(Moveset)-1);
        IndexOfAbility = 0;
        oPrideTarget();
        State = "ExecutePattern";
    break;
    
    case "ExecutePattern":
        CurrentAction = Moveset[CurrentPatternIndex,IndexOfAbility];

        if(IndexOfAbility &lt; array_length_2d(Moveset,CurrentPatternIndex))
        {
            
            if(target != noone)
            {   
                IndexOfAbility += 1;
                State = "CheckAbility";
            }
            else
            {
                State = "Idle";
                WaitTime = 5;
                WaitTimer = 0;
            }
        }
        else
        {
            State = "ChoosePattern";
        }
        
    break;
    
    
    case "PatternAdvance":
        CurrentAction = Moveset[CurrentPatternIndex,IndexOfAbility];
        oPrideTarget();
        IndexOfAbility += 1;
        State = "CheckAbility";
        //State = "FlyAway";
    
    break;
    
    case "Pissed":
        oPrideTarget();
        
        if instance_exists(target)
        {
            State = "Move";
        }
    
    break;
    
    case "CheckAbility":
        WaitBetweenAbilities -= DELTA_TIME;
        if WaitBetweenAbilities &lt;= 0
        {
            UseAbility = false;
            switch CurrentAction
            {
                case oPissed:
                    pissed = true;
                    pissedTime = 10;
                    State = "Pissing";
                break;
                
                case oDashPunch:
                    State = "Dash";
                    startX = x;
                    startY = y;
                    distance = point_distance(target.x,target.y,x,y);
                    dashTime = distance/dashSpeed
                    dashTimer = 0;
                    map[gridX,gridY].occupant = noone;
                break;
                
                case oSummonGoons:
                    State = "Summon";
                    WaitTimer = 0;
                    WaitTime = 5;
                break;
            }
        }
    break;
    
    case "Summon":
        if(!instance_exists(oGoon))
        {
            if sprite_index!=Summon
            {
                SetAnimation(Summon);
            }
            Timer += DELTA_TIME
            if Timer &gt;= AnimationTime
            {
                var summon;
                summon = instance_create(x,y,oSummonGoons);
                summon.gridX = 10;
                summon.gridY = 4;
                summon.State = "Summon";
                returnAnimation = SummonReturn;
                State = "Return";
            }
        }
        else
        {
            State = "Idle";
            WaitTimer = 0;
            WaitTime = 10;
        }
    break;
    
    case "WaitingReturn":

    break;
    
    case "Return":
        if sprite_index != returnAnimation{
            sprite_index = returnAnimation;
            image_index = 0;
            AnimationTime = image_number*DELTA_TIME/image_speed;
            Timer = 0;
            
        }
        Timer += DELTA_TIME;
        
        if Timer &gt;= AnimationTime
        {
            if goBack
            {
                State  = "GoBack";
                goBack = false;
            }
            else
            {
                State = "Idle";
            }
            
        }
    break;
    
    case "Waiting":
        sprite_index = Idle;
        WaitingTime -= DELTA_TIME;
        if WaitingTime &lt;= 0
        {
            State = "ChoosePattern";
        }
    break;
    
    case "Dead":
        if Death = false{
            if sprite_index != DeathAnimation{
                sprite_index = DeathAnimation;
                image_index = 0;
                AnimationTime = image_number*DELTA_TIME/image_speed;
                Timer = 0;
            }
            Timer += DELTA_TIME;
            
            if Timer &gt;= AnimationTime{
                sprite_index = Dead;
                image_index = 0;
                Death = true;
                oBattleScreen.EncounterSize = 0;
            }
        }
    break;
    
    
    case "Stunned":
        if IndexOfAbility &gt; 2{
            State = "ChoosePattern";
        }else{
            State = "ExecutePattern";
        }
    break;
    
    case "Dash":
    
        if dashTimer &lt; 0.5
        {   
            sprite_index = Dash;
            targetX = target.gridX;
            targetY = target.gridY;
            endX = target.x;
            endY = target.y;
        }
        else
        {
            sprite_index = Windup;
        }
        dashTimer += DELTA_TIME/dashTime
        
        x = MoveInBezierCurve(dashTimer,startX,midX,endX);
        y = MoveInBezierCurve(dashTimer,startY,midY,endY);
        
        if dashTimer &gt;= 1
        {
            WaitTimer = 0;
            WaitTime = 5;
            State = "Punch";
        }
        
    break;
    
    case "Punch":
        if sprite_index != Punch
        {
            SetAnimation(Punch);
        }
        Timer += DELTA_TIME;
        if(Timer &gt;= AnimationTime)
        {
            if map[targetX,targetY].occupant != noone
            {
                var punch;
                punch = instance_create(x,y,oDashPunch);
                punch.Owner = id;
                punch.target = map[targetX,targetY].occupant;
                punch.startX = target.x;
                punch.startY = target.y;
                State = "Return";
                returnAnimation = Hit
                goBack = true;
            }
            else
            {
                map[targetX,targetY].occupant = id;
                State = "Return";
                returnAnimation = Miss
                goBack = true;
            }
        }
    break;
    
        
    case "GoBack":
        if sprite_index != Jump
        {
            SetAnimation(Jump);
        }
        Timer += DELTA_TIME
        if Timer&gt;= AnimationTime
        {
            if map[targetX,targetY].occupant == id
            {
                map[targetX,targetY].occupant = noone;
            }
            State = "Jumping";
            sprite_index = Jumping;
            dashTimer = 0;

            endX = map[gridX,gridY].x;
            endY = map[gridX,gridY].y;
            startX = x;
            startY = y;
            if endX &gt; x
            {
                midX = x + abs(endX-x);
            }
            else
            {
                midX = x - abs(x-endX);
            }
            
            if endY &lt; y
            {
                midY = endY - 50;;
            }
            else
            {
                midY = y - 50;;
            }
        }
    break;
    
    case "Jumping":
        dashTimer += DELTA_TIME/dashTime;
        
        x = MoveInBezierCurve(dashTimer,startX,midX,endX);
        y = MoveInBezierCurve(dashTimer,startY,midY,endY);
        
        if dashTimer &gt;= 1
        {
            State = "Return";
            returnAnimation = Landing;
            if map[gridX,gridY].occupant != noone
            {
                map[gridX,gridY].occupant.State = "Dead";
            }
            map[gridX,gridY].occupant = id;
        }
    break;
}
TakeDamage();
//If we have been hit 
if Shake{
    
    ShakeTime += DELTA_TIME;
    if ShakeTime &lt; ShakeDuration{
        CurrentX = map[gridX,gridY].x;
        x = CurrentX + SpriteShakeAmount*(sign(ShakeDir)*(ShakeDuration-ShakeTime));
        ShakeDir = ShakeDir *(-1);
    }else{
        Shake = false;
        ShakeTime = 0;
        SpriteShakeAmount = 0;
    }
}

if pissed
{
    pissedTime -= DELTA_TIME;
    part_emitter_region(partSys,steamEmitter,x,x+5,y-20,y-15,ps_shape_rectangle,ps_distr_gaussian);
    part_emitter_stream(partSys,steamEmitter,steamEf,-20);
    if pissedTime &lt;= 0 and State != "Attack" and State != "Dead"
    {
        State = "Idle";
        part_emitter_clear(partSys,steamEmitter);
        pissed = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>part_emitter_destroy(partSys,steamEmitter);
part_type_destroy(steamEf);
part_system_destroy(partSys);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_text(x,y-100,State);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_sprite_ext(sprite_index,image_index,round(x),round(y),image_xscale,image_yscale,image_angle,c_white,image_alpha);


if(flash&gt;0.0)
{
    if(flashElapsed&lt;=0.0)
    {
        flash -= 1.5*DELTA_TIME
    }
    else
    {
        
        flashElapsed -= DELTA_TIME;
    }
    
    shader_set(HurtShader);
    shaderAlpha = shader_get_uniform(HurtShader,"_alpha");
    shader_set_uniform_f(shaderAlpha,flash);
    
    draw_sprite(sprite_index,image_index,round(x),round(y));
    shader_reset();


}

//TO DO- MAKE PISSED-OFF shader

if pissed
{
    shader_set(PissedShader);
    draw_sprite(sprite_index,image_index,round(x),round(y));
    shader_reset();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
